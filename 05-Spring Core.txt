Spring Core 
---

 1. What is Spring Core?

Spring Core refers to the essential module of the Spring Framework that provides the core functionality, including Inversion of Control (IoC) 
and Dependency Injection (DI). It is the foundation of the entire Spring Framework. The IoC container is responsible for managing the lifecycle of beans 
(objects), and DI allows for decoupling of application components by injecting dependencies rather than hard-coding them.

---

 2. What is Inversion of Control (IoC) in Spring?
  
Inversion of Control (IoC) is a design principle where the control of object creation and management is shifted from the application code 
to a container or framework. In Spring, the IoC container is responsible for creating and managing beans (objects). 
The container injects the dependencies into the objects (beans) rather than the objects creating their dependencies themselves. 
This promotes loose coupling and makes the application easier to manage and test.

---

 3. What is Dependency Injection (DI) in Spring?
  
Dependency Injection (DI) is a design pattern in which an object's dependencies (other objects it depends on) are provided to it rather than 
the object creating them itself. In Spring, DI is used to reduce the coupling between components, making it easier to manage and test applications. 
Spring supports DI via constructor injection, setter injection, and field injection.

---

 4. What are the different types of Dependency Injection in Spring?
  
Spring supports three types of Dependency Injection:
- Constructor Injection: Dependencies are provided through the class constructor.
	  ```java
	  public class MyService {
		  private final MyRepository repository;
		  
		  public MyService(MyRepository repository) {
			  this.repository = repository;
		  }
	  }
	  ```
- Setter Injection: Dependencies are provided via setter methods after the bean is created.
	  ```java
	  public class MyService {
		  private MyRepository repository;
		  
		  public void setRepository(MyRepository repository) {
			  this.repository = repository;
		  }
	  }
	  ```
- Field Injection: Dependencies are injected directly into fields using `@Autowired` annotation (less preferred due to reduced testability and control).
	  ```java
	  public class MyService {
		  @Autowired
		  private MyRepository repository;
	  }
	  ```
---

 5. What is a Spring Bean?
  
A Spring Bean is an object that is managed by the Spring IoC container. 
Beans are created, configured, and managed by the container and can be injected into other components as dependencies. 
Beans are defined either through annotations (e.g., `@Component`, `@Service`, `@Repository`) or XML configuration.

---

 6. What is the Spring IoC Container?

The Spring IoC (Inversion of Control) Container is responsible for managing the lifecycle of beans in a Spring application. 
It creates, configures, and injects dependencies into beans. There are two main types of Spring containers:
- BeanFactory: The simplest container, which lazily loads beans.
- ApplicationContext: A more advanced container, which eagerly loads beans and offers additional features like event propagation, AOP support, etc.

---

 7. What are the different types of Spring Bean scopes?
  
Spring supports several bean scopes that define the lifecycle and visibility of beans within the container:
- Singleton (default): Only one instance of the bean is created per Spring container.
- Prototype: A new instance of the bean is created every time it is requested or needed.
- Request: For every HTTP request a new instance of the bean is created.
- Session: For every HTTP Session a new instance of the bean is created.
- Global-session: One instance for the global HTTP session (for portlet applications).

---

 8. What is the difference between ApplicationContext and BeanFactory?

- BeanFactory: The basic Spring container that provides the core functionality for bean creation and dependency injection. 
               Beans are created lazily (only when requested).
- ApplicationContext: A more advanced container that builds on `BeanFactory`. It provides additional features such as event handling, 
                      AOP support, and internationalization. Beans are created eagerly (at startup).

---

 9. What is the use of the `@Component` annotation in Spring?
  
The `@Component` annotation is used to mark a class as a Spring bean, 
indicating that it should be automatically detected and registered by Spring's classpath scanning mechanism. 
It is a general-purpose annotation, and specialized versions of it are available for specific layers of an application:

- @Service: Used for service-layer beans (business logic).
- @Repository: Used for data access layer beans.
- @Controller: Used for controller beans in Spring MVC.

---

 10. What is the `@Autowired` annotation in Spring?

The `@Autowired` annotation is used to automatically inject dependencies into a Spring bean. 
Spring uses this annotation to resolve and inject the required dependencies at runtime. 
The injection can be done via constructor, setter, or field injection. 
If no matching bean is found, Spring throws an exception unless the dependency is marked as optional.

---

 13. What is the `@Qualifier` annotation in Spring?

The `@Qualifier` annotation is used in conjunction with `@Autowired` to specify which bean should be injected when multiple beans of the same type exist. 
It resolves ambiguity when Spring cannot automatically determine which bean to inject.

	```java
	@Autowired
	@Qualifier("myRepository")
	private MyRepository repository;
	```
---

 14. What is the Spring Bean lifecycle?

The Spring Bean lifecycle consists of several phases:
1. Instantiation: The Spring container creates a new instance of the bean class. This is the first step when a bean is needed in the application.
2. Dependency Injection: Spring injects any dependencies into the bean (e.g., other beans or configuration properties) that are required by the bean.
3. Bean Initialization:
   - `@PostConstruct`: If there is a method annotated with `@PostConstruct`, it is called after the bean's dependencies are injected 
					   and before the bean is fully initialized. This method can be used to perform setup tasks.
   - `InitializingBean` Interface: If the bean implements `InitializingBean`, the `afterPropertiesSet()` method is called.
   - Custom Init Method: You can also define a custom initialization method using the `@Bean(initMethod = "initMethodName")` annotation or in XML configuration.
4. Bean is Ready for Use: The bean is now fully initialized and ready to be used within the application.
5. Destruction:
   - `@PreDestroy`: If a method is annotated with `@PreDestroy`, it will be called just before the bean is destroyed. This is used for cleanup tasks.
   - `DisposableBean` Interface: If the bean implements `DisposableBean`, the `destroy()` method is called.
   - Custom Destroy Method: You can define a custom destroy method using the `@Bean(destroyMethod = "destroyMethodName")` annotation or in XML configuration.

---

 15. What is the role of `@PostConstruct` and `@PreDestroy` annotations in Spring?

  
- `@PostConstruct`: Indicates that the annotated method should be run after the bean has been initialized and all dependencies have been injected.
- `@PreDestroy`: Indicates that the annotated method should be run just before the bean is destroyed, which is typically used for cleanup.

	```java
	@PostConstruct
	public void init() {
		// Initialization logic
	}

	@PreDestroy
	public void cleanup() {
		// Cleanup logic
	}
	```
---

 16. What is the `@Value` annotation in Spring?
  
The `@Value` annotation is used to inject values into fields, methods, or constructor arguments. 
It can be used to inject values from property files, system properties, or expressions.

	```java
	@Value("${database.url}")
	private String databaseUrl;
	```
---

 17. What is the role of `@Scope` annotation in Spring?
  
The `@Scope` annotation is used to specify the scope of a Spring bean, i.e., 
how long a bean should live and how many instances of it should be created. Common scopes include:

- Singleton: One instance of the bean per Spring container (default).
- Prototype: A new instance every time the bean is requested.
- Request: One instance per HTTP request (for web applications).
- Session: One instance per HTTP session (for web applications).

	```java
	@Scope("prototype")
	public class MyBean {
	}
	```
---

 18. What is the purpose of `BeanPostProcessor` in Spring?
  
`BeanPostProcessor` is an interface in Spring that allows you to perform operations on beans before and after their initialization. 
This is useful for tasks such as modifying bean properties, wrapping beans, or applying additional logic during the bean lifecycle.

	```java
	public class MyBeanPostProcessor implements BeanPostProcessor {
		@Override
		public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
			// Logic before initialization
			return bean;
		}

		@Override
		public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
			// Logic after initialization
			return bean;
		}
	}
	```
---

 19. What is `@Configuration` and how does it differ from a regular class?

`@Configuration` is a special type of class in Spring that is used for Java-based configuration. 
It indicates that the class contains bean definitions. It differs from regular classes in that it can use the `@Bean` annotation to define beans explicitly. 
Moreover, classes annotated with `@Configuration` are processed by Spring to generate proxy objects to ensure that the beans are defined correctly 
and to support the features of the configuration, such as scope management.

	```java
	@Configuration
	public class AppConfig {
		@Bean
		public MyService myService() {
			return new MyServiceImpl();
		}
	}
	```
Difference from Regular Class:  
A class annotated with `@Configuration` is treated by Spring as a configuration class, while a regular class is just a plain class.

---

 20. What is the role of the `@Bean` annotation in Spring?
  
The `@Bean` annotation is used to explicitly declare a Spring bean in a `@Configuration` class. 
It marks a method as responsible for creating and configuring a bean, which will be managed by the Spring container. 
This allows you to define beans using Java configuration instead of XML.

	```java
	@Configuration
	public class AppConfig {
		@Bean
		public MyBean myBean() {
			return new MyBean();
		}
	}
	```
---

 21. What is the `@Profile` annotation in Spring?

The `@Profile` annotation is used to specify that a bean should only be created in certain environments or profiles. 
It helps you manage beans in different environments (e.g., development, production) by defining which beans are available under which profiles.

	```java
	@Configuration
	@Profile("dev")
	public class DevConfig {
		@Bean
		public DataSource devDataSource() {
			return new DataSource("dev-database-url");
		}
	}

	@Configuration
	@Profile("prod")
	public class ProdConfig {
		@Bean
		public DataSource prodDataSource() {
			return new DataSource("prod-database-url");
		}
	}
	```
You can activate profiles using the `spring.profiles.active` property.

---

 22. What is `@Lazy` annotation in Spring and when should it be used?

The `@Lazy` annotation is used to indicate that a bean should be lazily initialized, i.e., 
it should not be created at startup, but only when it is first accessed. 
This can help improve application startup time by deferring the creation of certain beans.

	```java
	@Lazy
	@Component
	public class MyService {
		// Bean created lazily
	}
	```
Use `@Lazy` when you have beans that are resource-intensive or not always required.

---

 23. What is `@Primary` annotation in Spring?

The `@Primary` annotation is used to give a higher priority to a bean when multiple beans of the same type exist, 
and Spring needs to decide which bean to inject. This is typically used with `@Autowired` to resolve ambiguity between multiple beans of the same type.

	```java
	@Bean
	@Primary
	public MyService myService1() {
		return new MyServiceImpl1();
	}

	@Bean
	public MyService myService2() {
		return new MyServiceImpl2();
	}
	```
In this case, `myService1` will be injected by default, unless otherwise specified using `@Qualifier`.

---

 24. What is the significance of `ApplicationContext` in Spring?

`ApplicationContext` is the central interface to the Spring IoC container. 
It provides methods for accessing beans, managing their lifecycle, and handling bean configuration. 
It also adds additional features, such as event propagation, AOP (Aspect-Oriented Programming) support, and internationalization.

Some common implementations of `ApplicationContext` are:
- ClassPathXmlApplicationContext: Loads the context from an XML configuration file.
- AnnotationConfigApplicationContext: Loads the context from Java-based configuration classes.
- GenericWebApplicationContext: For web applications with Spring.

---

 25. What are `BeanDefinition` and `BeanFactory` in Spring?

- BeanDefinition: A `BeanDefinition` is a metadata representation of a Spring bean. 
				  It contains information about the bean’s class, its dependencies, and lifecycle configuration. 
				  The `BeanDefinition` defines how a bean will be created, initialized, and destroyed.
  
- BeanFactory: The `BeanFactory` is the interface for the basic container that provides the functionality for bean creation and dependency injection. 
			   It is a more lightweight version of the `ApplicationContext`. 
			   It is rarely used in favor of `ApplicationContext` but is suitable for simple applications.
---

 26. What is the difference between `@Autowired` and `@Resource` annotations?
  
- `@Autowired`: The `@Autowired` annotation is a Spring-specific annotation that can be used to inject dependencies by type. 
				Spring automatically injects the matching bean into the annotated field, setter, or constructor.

	```java
	@Autowired
	private MyService myService;
	```

- `@Resource`: `@Resource` is part of Java’s JSR-250 specification and injects beans by name (if no name is provided, it defaults to the field name). 
				If no bean with the given name exists, it will fall back to injecting by type.

	```java
	@Resource(name="myService")
	private MyService myService;
	```
---

 27. What is the difference between `@Bean` and `@Component` annotations?

- `@Bean`: Used in Java-based configuration to explicitly define a method that creates and returns a bean. 
		   It is part of `@Configuration`-annotated classes.
		   
	```java
	@Configuration
	public class AppConfig {
		@Bean
		public MyBean myBean() {
			return new MyBean();
		}
	}
	```
- `@Component`: Marks a class as a Spring-managed bean, and Spring automatically detects it through component scanning. 
				It is used on classes that are automatically instantiated by the Spring container.

	```java
	@Component
	public class MyBean {
		// Spring automatically detects and registers this bean
	}
	```
---

 28. What is `@Scope` annotation in Spring?
  
The `@Scope` annotation is used to define the scope of a bean, which determines its lifecycle. Commonly used scopes include:
- Singleton: Only one instance of the bean is created (default).
- Prototype: A new instance is created every time the bean is requested.
- Request: A new instance is created for each HTTP request (used in web applications).
- Session: A new instance is created for each HTTP session.
- Application: A single instance is created for the entire lifecycle of a web application.

	```java
	@Scope("prototype")
	@Component
	public class MyBean {
		// A new instance of MyBean will be created each time it is requested.
	}
	```
---

 29. What is `@PostConstruct` and `@PreDestroy` in Spring?

- `@PostConstruct`: The `@PostConstruct` annotation marks a method to be executed after the bean’s dependencies have been injected and the bean has been initialized.
- `@PreDestroy`: The `@PreDestroy` annotation marks a method to be executed just before the bean is destroyed (when the Spring container is shutting down).

	```java
	@PostConstruct
	public void init() {
		// Initialization logic
	}

	@PreDestroy
	public void cleanup() {
		// Cleanup logic
	}
	```
---

 30. What is a `BeanFactoryPostProcessor` in Spring?
  
`BeanFactoryPostProcessor` is an interface that allows you to modify the BeanDefinition before the beans are instantiated. 
It is executed before any beans are created, giving you the opportunity to change bean properties or add additional logic.

Example usage:
	```java
	public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
		@Override
		public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
			// Modify BeanDefinition or bean properties
		}
	}
	```
---

 31. What is a `BeanPostProcessor` in Spring?
  
`BeanPostProcessor` is an interface that allows you to intercept the bean creation process, giving you the opportunity 
to modify or wrap beans before and after their initialization. It’s useful for tasks like logging, modifying bean properties, or applying AOP.

	```java
	public class MyBeanPostProcessor implements BeanPostProcessor {
		@Override
		public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
			// Modify bean before initialization
			return bean;
		}

		@Override
		public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
			// Modify bean after initialization
			return bean;
		}
	}
	```
---

 32. What is `@Import` annotation in Spring?

The `@Import` annotation is used to import other `@Configuration` classes into the current configuration. 
This is useful for modularizing your configuration, especially when dealing with multiple configuration classes.

	```java
	@Configuration
	@Import({DataConfig.class, ServiceConfig.class})
	public class AppConfig {
		// This will import DataConfig and ServiceConfig into AppConfig
	}
	```
---

https://www.digitalocean.com/community/tutorials/java-multithreading-concurrency-interview-questions-answers

Multithreading
---

# 1. What is a thread in Java, and how is it created?

   - A thread is a lightweight process that can run concurrently with other threads in a Java application. 
   It allows for multitasking, enabling the execution of multiple parts of a program simultaneously.
   - Creating a Thread:
     - By extending the `Thread` class:
       ```java
       class MyThread extends Thread {
           public void run() {
               // Code to execute in the thread
           }
       }
       MyThread thread = new MyThread();
       thread.start(); // Starts the thread
       ```
     - By implementing the `Runnable` interface:
       ```java
       class MyRunnable implements Runnable {
           public void run() {
               // Code to execute in the thread
           }
       }
       Thread thread = new Thread(new MyRunnable());
       thread.start(); // Starts the thread
       ```

# 2. What is the difference between Runnable and Thread?

   - Runnable is an interface that represents a task that can be executed by a thread. It defines a single method, `run()`, which contains the code to be executed.
   - Thread is a class that represents a thread of execution. It can be created by extending the `Thread` class or by using the `Runnable` interface.
   - Key Differences:
     - Extensibility: You can extend only one class in Java, so using `Runnable` allows you to extend another class as well.
     - Resource Sharing: Runnable instances can be shared between multiple threads, while each thread created from the `Thread` class is independent.

# 3. Explain the difference between sleep() and wait().

   - sleep():
     - Belongs to the `Thread` class.
     - Puts the thread to sleep for a specified time (in milliseconds).
     - Does not release any locks or monitors.
     - Example: `Thread.sleep(1000);` pauses the thread for 1 second.
   
   - wait():
     - Belongs to the `Object` class.
     - Causes the current thread to wait until another thread invokes `notify()` or `notifyAll()` on the same object.
     - Releases the lock on the object it is called on, allowing other threads to access the synchronized block.
     - Must be called from a synchronized context.

# 4. What is thread synchronization, and why is it important?

   - Thread synchronization is a technique used to control the access of multiple threads to shared resources, preventing data inconsistency and race conditions.
   - It is important because when multiple threads try to read and write shared data at the same time, it can lead to unpredictable behavior and data corruption.
   - Example: Using the `synchronized` keyword on methods or blocks ensures that only one thread can execute that code at a time.

# 5. What is a deadlock, and how can you avoid it?

   - A deadlock occurs when two or more threads are waiting for each other to release resources, causing all of them to be stuck indefinitely.
   - Example: Thread A holds Resource 1 and waits for Resource 2, while Thread B holds Resource 2 and waits for Resource 1.
   - How to Avoid Deadlocks:
     - Lock ordering: Always acquire locks in a consistent order.
     - Timeouts: Use timeouts when trying to acquire locks to avoid waiting indefinitely.
     - Using a single lock: If possible, design your application to use a single lock to control access to resources.

# 6. Explain ExecutorService and Callable in Java.

   - ExecutorService:
     - An interface that provides a higher-level replacement for managing threads. It allows you to create a thread pool, manage task execution, and handle results more efficiently.
     - You can submit tasks (Runnable or Callable) and manage their execution.
     - Example:
       ```java
       ExecutorService executor = Executors.newFixedThreadPool(5);
       executor.submit(() -> {
           // Task code here
       });
       executor.shutdown(); // Stops accepting new tasks
       ```

   - Callable:
     - An interface similar to `Runnable`, but it can return a result and throw checked exceptions.
     - The `call()` method is used to define the task to be executed, and it can return a value.
     - Example:
       ```java
       Callable<Integer> task = () -> {
           // Task code
           return 42; // Return a result
       };
       Future<Integer> future = executor.submit(task);
       Integer result = future.get(); // Retrieves the result
       ```

---


1) What is the difference between Process and Thread?
A process is a self contained execution environment and it can be seen as a program or application 
whereas Thread is a single task of execution within the process. Java runtime environment runs as a single process 
which contains different classes and programs as processes. Thread can be called lightweight process. 
Thread requires less resources to create and exists in the process, thread shares the process resources.

2) What are the benefits of multi-threaded programming?
In Multi-Threaded programming, multiple threads are executing concurrently that improves the performance 
because CPU is not idle incase some thread is waiting to get some resources. Multiple threads share the heap memory, 
so it’s good to create multiple threads to execute some task rather than creating multiple processes. 
For example, Servlets are better in performance than CGI because Servlet support multi-threading but CGI doesn’t.

3) What is difference between user Thread and daemon Thread?
When we create a Thread in java program, it’s known as user thread. 
A daemon thread runs in background and doesn’t prevent JVM from terminating. 
When there are no user threads running, JVM shutdown the program and quits. 
A child thread created from daemon thread is also a daemon thread.

4) What are different states in lifecycle of Thread?
When we create a Thread in java program, its state is New. 
Then we start the thread that change it's state to Runnable. 
Thread Scheduler is responsible to allocate CPU to threads in Runnable thread pool and change their state to Running. 
Other Thread states are Waiting, Blocked and Dead. 
Read this post to learn more about [life cycle of thread](/community/tutorials/thread-life-cycle-in-java-thread-states-in-java).

5) Can we call run() method of a Thread class?
Yes, we can call run() method of a Thread class but then it will behave like a normal method. 
To actually execute it in a Thread, we need to start it using **Thread.start()** method.

6) How can we pause the execution of a Thread for specific time?
We can use Thread class sleep() method to pause the execution of Thread for certain time. 
Note that this will not stop the processing of thread for specific time, once the thread awake from sleep, 
it's state gets changed to runnable and based on thread scheduling, it gets executed.

7) What do you understand about Thread Priority?
Every thread has a priority, usually higher priority thread gets precedence in execution but it depends on Thread Scheduler implementation that is OS dependent. 
We can specify the priority of thread but it doesn't guarantee that higher priority thread will get executed before lower priority thread. 
Thread priority is an _int_ whose value varies from 1 to 10 where 1 is the lowest priority thread and 10 is the highest priority thread.

8) What is Thread Scheduler and Time Slicing?
Thread Scheduler is the Operating System service that allocates the CPU time to the available runnable threads. 
Once we create and start a thread, it's execution depends on the implementation of Thread Scheduler. 
Time Slicing is the process to divide the available CPU time to the available runnable threads. 
Allocation of CPU time to threads can be based on thread priority or the thread waiting for longer time will get more 
priority in getting CPU time. Thread scheduling can't be controlled by java, so it's always better to control it from application itself.

9) What is context-switching in multi-threading?
Context Switching is the process of storing and restoring of CPU state so that 
Thread execution can be resumed from the same point at a later point of time. 
Context Switching is the essential feature for multitasking operating system and support for multi-threaded environment.

10) How can we make sure main() is the last thread to finish in Java Program?
We can use Thread join() method to make sure all the threads created by the program is dead before finishing the main function. 
Here is an article about [Thread join method](/community/tutorials/java-thread-join-example).

11) How does thread communicate with each other?
When threads share resources, communication between Threads is important to coordinate their efforts. 
Object class wait(), notify() and notifyAll() methods allows threads to communicate about the lock status of a resource. 
Check this post to learn more about [thread wait, notify and notifyAll](/community/tutorials/java-thread-wait-notify-and-notifyall-example).

12) Why thread communication methods wait(), notify() and notifyAll() are in Object class?
In Java every Object has a monitor and wait, notify methods are used to wait for 
the Object monitor or to notify other threads that Object monitor is free now. 
There is no monitor on threads in java and synchronization can be used with any Object, 
that's why it's part of Object class so that every class in java has these essential methods for inter thread communication.


13) Why wait(), notify() and notifyAll() methods have to be called from synchronized method or block?
When a Thread calls wait() on any Object, it must have the monitor on the Object that it will leave and goes in wait state 
until any other thread call notify() on this Object. Similarly when a thread calls notify() on any Object, it leaves the monitor 
on the Object and other waiting threads can get the monitor on the Object. Since all these methods require Thread to have the Object monitor, 
that can be achieved only by synchronization, they need to be called from synchronized method or block.

14) Why Thread sleep() and yield() methods are static?
Thread sleep() and yield() methods work on the currently executing thread. 
So there is no point in invoking these methods on some other threads that are in wait state. 
That’s why these methods are made static so that when this method is called statically, 
it works on the current executing thread and avoid confusion to the programmers who might 
think that they can invoke these methods on some non-running threads.

15) How can we achieve thread safety in Java?
There are several ways to achieve thread safety in java - synchronization, atomic concurrent classes, 
implementing concurrent Lock interface, using volatile keyword, using immutable classes and Thread safe classes. 
Learn more at [thread safety tutorial](/community/tutorials/thread-safety-in-java).

16) What is volatile keyword in Java?
When we use volatile keyword with a variable, all the threads read it's value directly from the memory and don't cache it. 
This makes sure that the value read is the same as in the memory.


17) Which is more preferred - Synchronized method or Synchronized block?
Synchronized block is more preferred way because it doesn't lock the Object, 
synchronized methods lock the Object and if there are multiple synchronization blocks in the class, 
even though they are not related, it will stop them from execution and put them in wait state to get the lock on Object.

18) How to create daemon thread in Java?
Thread class setDaemon(true) can be used to create daemon thread in java. 
We need to call this method before calling start() method else it will throw IllegalThreadStateException.

19) What is ThreadLocal?
Java ThreadLocal is used to create thread-local variables. We know that all threads of an Object share it’s variables, 
so if the variable is not thread safe, we can use synchronization but if we want to avoid synchronization, we can use ThreadLocal variables. 
Every thread has its own ThreadLocal variable and they can use it gets () and set() methods to get the default value or change it’s value local to Thread. 
ThreadLocal instances are typically private static fields in classes that wish to associate the state with a thread. 
Check this post for small example program showing [ThreadLocal Example](/community/tutorials/java-threadlocal-example).

20) What is Thread Group? Why it’s advised not to use it?
ThreadGroup is a class which was intended to provide information about a thread group. 
ThreadGroup API is weak and it doesn't have any functionality that is not provided by Thread. 
It has two main features - to get the list of active threads in a thread group and to set the uncaught exception handler for the thread. 
But Java 1.5 has added _setUncaughtExceptionHandler(UncaughtExceptionHandler eh)_ method using which we can add uncaught exception handler to the thread. 
So ThreadGroup is obsolete and hence not advised to use anymore.

```
t1.setUncaughtExceptionHandler(new UncaughtExceptionHandler(){

@Override
public void uncaughtException(Thread t, Throwable e) {
    System.out.println("exception occured:"+e.getMessage());
}
            
});
```

21) What is Java Thread Dump, How can we get Java Thread dump of a Program?
A thread dump is a list of all the threads active in the JVM, thread dumps are very helpful in analyzing bottlenecks in the application and 
analyzing deadlock situations. There are many ways using which we can generate Thread dump - Using Profiler, Kill -3 command, jstack tool, etc. 
I prefer jstack tool to generate thread dump of a program because it's easy to use and comes with JDK installation. Since it's a terminal-based tool, 
we can create a script to generate thread dump at regular intervals to analyze it later on. 
Read this post to know more about [generating thread dump in java](/community/tutorials/java-thread-dump-visualvm-jstack-kill-3-jcmd).

22) What is Deadlock? How to analyze and avoid deadlock situation?
Deadlock is a programming situation where two or more threads are blocked forever, 
this situation arises with at least two threads and two or more resources. 
To analyze a deadlock, we need to look at the java thread dump of the application, 
we need to look out for the threads with state as BLOCKED and then the resources it’s waiting to lock, 
every resource has a unique ID using which we can find which thread is already holding the lock on the object. 
Avoid Nested Locks, Lock Only What is Required and Avoid waiting indefinitely are common ways to avoid deadlock situation, 
read this post to learn how to [analyze deadlock in java](/community/tutorials/deadlock-in-java-example) with a sample program.

23) What is Java Timer Class? How to schedule a task to run after specific interval?
java.util.Timer is a utility class that can be used to schedule a thread to be executed at a certain time in future. 
Java Timer class can be used to schedule a task to be run one-time or to be run at regular intervals. 
java.util.TimerTask is an **[abstract class](/community/tutorials/abstract-class-in-java "Abstract Class in Java with Example")** 
that implements Runnable interface and we need to extend this class to create our own TimerTask that can be scheduled using java Timer class. 
Check this post for [java Timer example](/community/tutorials/java-timer-timertask-example).

24) What is Thread Pool? How can we create Thread Pool in Java?
A thread pool manages the pool of worker threads, it contains a queue that keeps tasks waiting to get executed. 
A thread pool manages the collection of Runnable threads and worker threads execute Runnable from the queue. 
java.util.concurrent.Executors provide implementation of java.util.concurrent.Executor interface to create the thread pool in java. 
[Thread Pool Example](/community/tutorials/threadpoolexecutor-java-thread-pool-example-executorservice) program shows how to create and use Thread Pool in java. 
Or read [ScheduledThreadPoolExecutor Example](/community/tutorials/java-scheduler-scheduledexecutorservice-scheduledthreadpoolexecutor-example) 
to know how to schedule tasks after certain delay.

25) What will happen if we don’t override Thread class run() method?
Thread class run() method code is as shown below.

```
public void run() {
    if (target != null) {
        target.run();
    }
}
```

Above target set in the init() method of Thread class and if we create an instance of Thread class as `new TestThread()`, 
it's set to null. So nothing will happen if we don't override the run() method. Below is a simple example demonstrating this.

```
public class TestThread extends Thread {

	//not overriding Thread.run() method
	
	//main method, can be in other class too
	public static void main(String args[]){
		Thread t = new TestThread();
		System.out.println("Before starting thread");
		t.start();
		System.out.println("After starting thread");
	}
}
```

It will print only below output and terminate.

```
Before starting thread
After starting thread
```

# Multithreading and Concurrency

Q. Can you use a HashMap in a multithreaded environment? Why or why not?

No, a HashMap cannot be directly used in a multithreaded environment because it is not thread-safe. 
Because if more than one thread is modifying the HashMap simultaneously it can lead to data corruption.

To make it thread-safe, you can use Collections.synchronizedMap() method or ConcurrentHashMap, 
which is specifically designed for concurrent access and better performance by using segment-based locking. 


Q. What are the key differences between HashMap and ConcurrentMap?

HashMap is a non-thread-safe collection designed for single-threaded environments. 
It allows one null key and multiple null values, but concurrent modifications can lead to data corruption. 

On the other hand, ConcurrentMap is an interface implemented by thread-safe classes like ConcurrentHashMap. 
It prevents data inconsistency by using fine-grained locking, does not allow null keys or values, 
and provides atomic methods like putIfAbsent() and remove(). 

While HashMap is faster in single-threaded environments, ConcurrentMap is optimized for multi-threaded use, 
making it the better choice for concurrent applications.


Q. How does multithreading work with ConcurrentMap?

Unlike synchronized collections that lock the entire map, ConcurrentHashMap uses fine-grained locking or lock-striping. 
The map is divided into multiple segments, and each segment can be locked independently. 
This allows multiple threads to operate on different segments simultaneously.

Reads are performed without locking, hence threads will read the map concurrently without waiting, even while other threads are writing.

Atomic Operations
It provides atomic methods like putIfAbsent(), remove(key, value), and replace(key, oldValue, newValue) to prevent race conditions.
For example, putIfAbsent(key, value) ensures that a value is added only if the key is not already present, avoiding potential conflicts.

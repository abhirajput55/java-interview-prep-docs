Class Loader Subsystem is responsible for three things.
1) Loading
2) Linking
3) Initialization

Loading

Loading means reading class files located in hard disk and stores corresponding binary data in method area.
For each class file JVM will store corresponding information in method area.
1) Fully qualified name of class
name of parent
method information
variables information
constructure information
modifiers information
constant pool

After loading .class file immediatly jvm will creates an object for the loaded class in heap memory of type java.lang.class
The class Class object can be used by programmer to get class level information like method, variables, constructure information etc.

How to use the class Class object

Class c = Class.forName("java.lang.Object");
Method[] m = c.getDeclaredMethods();

For every loaded type only one class object will be created even though we are using class multiple times in our program.

Student s1 = new Student();
Class c1 = s1.getClass();

Student s2 = new Student();
Class c2 = s2.getClass();

sysout(c1==c2);  -> true


Linking

Linking consist of three activities 
1) Verification
2) Preparation
3) Resolution

Verification - 
It is the process of ensuring that binary representation of a class is structurally corrected or not.
Weather .class file is generated by valid compiler or not.
Weather properly formated or not.

Internally bytecode Verifier is responsible for this activity.
Bytecode Verifier is the part of Class Loader Subsystem.
It verification fails the we will get java.lang.VerifierError.

Preparation -
In this phase JVM will allocate memory for class level static variables and assign default values.
Note: In initiialization phase original values will be assigned to the static variables and here only default values will be assigned.

Resolution
It is the process of replacing symbolic names in our program with originaal memory references from method area.

class Test {
	p s v main(String[] args){
		String s = new String("Abhi");
		Student stu = new Student();
	}
}

For the abocve class class loader loads 
Test.class
Object.class
String.class
Student.class

The names of this classes are stored in constant pool of Test class.
In resolution phase this name are replaced with original memory level references from method area.


Initialization -
In this all static variables are assigned with original values and static blocks will be executed from parent to child and from top to bottom.

While loading, linking and initiialization if any error occures then we will get runtime exception java.lang.LinkageError.


Types of Class Loaders

1) Bootstrap Class Loader
2) Extension Class Loader
3) Application Class Loader

1) Bootstrap Class Loader - 
It is responsible to load core java API classes. i.e. the classes present in rt.jar
 jdk\jre\lib\rt.jar.
 jdk\jre\lib\ this path is known as Bootstrap Classpath.
Bootstrap Class Loader is by default available with every JVM.
It is implemented in native languages like C/C++ and not implemented in java.

2) Extension Class Loader - 
It is the child class of Bootstrap Class Loader.
It is responsible to load classes from extension classpath(jdk\jre\lib\ext) i.e. jdk\jre\lib\ext\*.jar.
Extension class Loader is implemented in java and the corresponding .class file is 
sun.misc.Launcher$ExtClassLoader.class

3) Application Class Loader -
It is the child class of Extension Class Loader.
It is responsible to load classes from application classpath.
It internally uses Enviornment Variable Classpath.
Application Class Loader is implemented in java and the corresponding .class file name is 
sun.misc.Launcher$AppClassLoader.class.


Working of Class Loader Subsystem

Class Loader followes Delagation Hirarche Principal.
Whenver JVM come across a particular class first it will check wheatther the .class file is already loadaed or not if it is already loaded in method area then JVM will consider that loaded class.
If it is not loaded then JVM requests class loader subsystem to load that particular class.
Then class loader subsystem handovers the request to application class loader.
Application class loader delagets the request to extension class loader which intern delagets request to bootstrap class loader.
Then bootstrap class loader search in bootstrap classpath if it is available then the corresponding class will be loaded by bootstrap class loader.
It it is not available then bootstrap class loader delagets the request to extension class loader.
Extension class loader will search in extension classpath.
If it is available then it will be loaded otherwise extension class delagets the request to application class loader.
Application class loader will search in application classpath.
If it is available then it will be loaded otherwise we will get runtime error NoClassDefFoundError or ClassNotFoundException.

sysout(String.class.getClassLoader());
sysout(Test.class.getClassLoader());
sysout(Lombok.class.getClassLoader());

Bootstrap class loader is not java object hence we got null in the first case.
But extension and application class loaders are java objects hence we are getting corresponding outputs for the remaining 2 sysout.

Class loader subsystem will give the highest priority for bootstrap classpath and then extension classpath followed by application classpath.



Heap Area:-

For every JVM one heap area is available.
Heap area will be created at the time of JVM startup.
Objects and corresponding instance variables will be stored in the heap area.
Every array in java is object only hence arrays also will be stored in the heap area.
Heap area can be accessed by multiple threads and hence the data stored in heap memory is not thread safe.
Heap area need not be contineous.

Program to display heap memory statistics

A ajava application can communicate with JVM by using Runtime object.
Runtime class present in java.lang package and it is a singleton class.
We can create runtime object as follows.
Runtime r = Runtime.getRuntime();

Once we got runtime object we can call the following methods on that object.

maxMemory(); It return number of bytes of max memory allocated to the heap.
totalMemory(); It returns number of bytes of total memory allocated to the heap.
freeMemory(); It return number of bytes of free memory present in the heap.

class HeapMemory{

	p s v main(String[] args){
	
		Runtime r = Runtime.getRuntime();
		
		sysout(r.maxMemory());
		sysout(r.totalMemory()); initial memory
		sysout(r.freeMemory());
		sysout("consumed memory :: " + r.totalMemory() - r.freeMemory());
		
		This will gives output in terms of bytes.
		1 kb = 1024 bytes
		1 mb = 1024 * 1024 bytes
	}
}

How to set maximum and minimum heap sizes?

Heap is finet memory but based on our requirement we can set maximum and minimum heap sizes.
i.e. we can increase or decrease the heap size based on our requirement.
We can use the following flags with the java command.

1) -xmx to set maximum heap size(maxMemory)
ex. java -xmx512m HeapDemo
This command will set maximum heap size as 512mb.
2) -xms to set minimum heap size(totalMemory)
ex. java -xms64m HeapDemo
This command will set initial heap size as 64mb


Stack Memory:- 

For every thread JVM will create a seperate stack at the time of thread creation.
Each and every method call performned by that thread will be stored in the stack including local variables also.
After completing a method the corresponding entry from the stack will be removed after completing all method calls 
the stack will become empty and that empty stack will be destroyed by the JVM just before terminating the thread.
Each entry in the stack is called stack frame or activation record.

The data stored in the stack is available only for the corresponding thread and not available to the remaining threads.
Hence this data is thread safe.

Stack Frame Structure -

Each stack frame contains three parts.
1) Local Variable Array
2) Operand Stack
3) Frame Data

Local Variable Array:
It contains all parameters and local variables of the method.
Each slot in the array is of 4 bytes.
Values of type int, float and object reference occupy 1 entry in array.
Values of double and long occupy two consecative entries in the array.
byte, short and char values will be converted to int type before storing and occupy 1 slot.
But the way of storing boolean values is varid from JVM to JVM but most of the JVM's follow 1 slot for boolean values. 

Operand Stack:
JVM uses operand stack as workspace.
Some instructions can push values to the operand stack and some instructions can pop values from operand stack and some instructions can perform required operations.


Frame Data:
Frame data contains all symbolic references related to that method.
It also contains a reference to exception table which provides corresponding catch block information in the case of exception.


PC Registers(Program Counter Registers):-
For every thread a seperate PC register will be created at the time of thread creation.
PC registers contains the addresss of current executing instructions.
Once instruction execution completes automatically PC register will be increamented to hold address of next instruction.

Native Method Stack:-
For every thread JVM will create a seperate native method stack.
All native method calls invoked by the thread will be stored in the corresponding native method stack.

Note:
1) method area, heap area and stack area are considered as important memory areas with respect to programmer.
2) method area and heap area are per JVM whereas stack area, pc register and native method stack are per thread.

Static variables will be stored in method area.
Instance variables will be stored in heap area.
Local variables will be stored in stack area.